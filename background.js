// =============================================================================
// PERFECT INSTA POST - SERVICE WORKER (BACKGROUND.JS)
// Gestion de l'authentification Google OAuth avec chrome.identity
// =============================================================================

const CONFIG = {
    backend: {
        baseUrl: 'https://perfect-insta-extension-production.up.railway.app',
        endpoints: {
            auth: '/auth/google',
            userMe: '/api/user/me',
            generatePost: '/api/generate-post'
        }
    }
};

// √âtat global du service worker
let authState = {
    isAuthenticated: false,
    jwtToken: null,
    user: null
};

// =============================================================================
// INITIALISATION DU SERVICE WORKER
// =============================================================================

// Charger l'√©tat d'authentification au d√©marrage du service worker
chrome.runtime.onStartup.addListener(async () => {
    console.log('üöÄ Perfect Insta Service Worker - Startup');
    await loadAuthState();
});

chrome.runtime.onInstalled.addListener(async () => {
    console.log('üöÄ Perfect Insta Service Worker - Installed');
    await loadAuthState();
});

// Charger l'√©tat d'authentification depuis chrome.storage
async function loadAuthState() {
    try {
        const stored = await chrome.storage.local.get(['jwtToken', 'user']);
        if (stored.jwtToken && stored.user) {
            authState.jwtToken = stored.jwtToken;
            authState.user = stored.user;
            authState.isAuthenticated = true;
            console.log('‚úÖ Auth state charg√©:', stored.user.email);

            // Valider le token avec le backend
            await validateToken();
        } else {
            console.log('üîç Aucun √©tat d\'auth trouv√©');
            authState.isAuthenticated = false;
        }
    } catch (error) {
        console.error('‚ùå Erreur chargement auth state:', error);
        authState.isAuthenticated = false;
    }
}

// =============================================================================
// GESTION DES MESSAGES DEPUIS LE POPUP
// =============================================================================

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log('üì® Message re√ßu:', message.type);

    switch (message.type) {
        case 'LOGIN':
            handleLogin(sendResponse);
            return true; // R√©ponse asynchrone

        case 'GET_AUTH':
            sendResponse({
                isAuthenticated: authState.isAuthenticated,
                token: authState.jwtToken,
                user: authState.user
            });
            return false;

        case 'LOGOUT':
            handleLogout(sendResponse);
            return true; // R√©ponse asynchrone

        case 'VALIDATE_TOKEN':
            validateToken().then(() => {
                sendResponse({
                    isAuthenticated: authState.isAuthenticated,
                    user: authState.user
                });
            });
            return true; // R√©ponse asynchrone

        default:
            console.warn('‚ö†Ô∏è Type de message non reconnu:', message.type);
            sendResponse({ success: false, error: 'Type de message non reconnu' });
            return false;
    }
});

// =============================================================================
// AUTHENTIFICATION GOOGLE OAUTH
// =============================================================================

async function handleLogin(sendResponse) {
    try {
        console.log('üîê D√©marrage du flow OAuth...');

        // Obtenir l'URL de redirection Chrome
        const redirectUri = chrome.identity.getRedirectURL('oauth2');
        console.log('üìç Redirect URI:', redirectUri);

        // Construire l'URL d'auth vers notre backend
        const authUrl = `${CONFIG.backend.baseUrl}${CONFIG.backend.endpoints.auth}?redirect_uri=${encodeURIComponent(redirectUri)}`;
        console.log('üåê Auth URL:', authUrl);

        // Lancer le flow OAuth avec chrome.identity
        chrome.identity.launchWebAuthFlow(
            {
                url: authUrl,
                interactive: true
            },
            async (redirectedTo) => {
                if (chrome.runtime.lastError) {
                    console.error('‚ùå Erreur OAuth:', chrome.runtime.lastError);
                    sendResponse({
                        success: false,
                        error: chrome.runtime.lastError.message
                    });
                    return;
                }

                if (!redirectedTo) {
                    console.error('‚ùå Aucune URL de redirection re√ßue');
                    sendResponse({
                        success: false,
                        error: 'Aucune URL de redirection re√ßue'
                    });
                    return;
                }

                console.log('üîó Redirection re√ßue:', redirectedTo);

                // Extraire le token depuis l'URL de redirection
                // Format attendu: https://extensionid.chromiumapp.org/oauth2#token=JWT_TOKEN&user=USER_DATA
                try {
                    const url = new URL(redirectedTo);
                    const hash = url.hash.substring(1); // Enlever le #
                    const params = new URLSearchParams(hash);

                    const token = params.get('token');
                    const userStr = params.get('user');

                    if (!token || !userStr) {
                        throw new Error('Token ou donn√©es utilisateur manquants dans la r√©ponse');
                    }

                    const user = JSON.parse(decodeURIComponent(userStr));

                    // Sauvegarder l'√©tat d'auth
                    await saveAuthState(token, user);

                    console.log('‚úÖ Connexion r√©ussie:', user.email);
                    sendResponse({
                        success: true,
                        token: token,
                        user: user
                    });

                } catch (parseError) {
                    console.error('‚ùå Erreur parsing r√©ponse OAuth:', parseError);
                    sendResponse({
                        success: false,
                        error: 'Erreur lors du traitement de la r√©ponse OAuth: ' + parseError.message
                    });
                }
            }
        );

    } catch (error) {
        console.error('‚ùå Erreur g√©n√©rale lors du login:', error);
        sendResponse({
            success: false,
            error: 'Erreur g√©n√©rale: ' + error.message
        });
    }
}

// Sauvegarder l'√©tat d'authentification
async function saveAuthState(token, user) {
    try {
        // Sauvegarder en local
        await chrome.storage.local.set({
            jwtToken: token,
            user: user
        });

        // Mettre √† jour l'√©tat du service worker
        authState.jwtToken = token;
        authState.user = user;
        authState.isAuthenticated = true;

        console.log('üíæ √âtat d\'auth sauvegard√© pour:', user.email);
    } catch (error) {
        console.error('‚ùå Erreur sauvegarde auth state:', error);
        throw error;
    }
}

// =============================================================================
// D√âCONNEXION
// =============================================================================

async function handleLogout(sendResponse) {
    try {
        console.log('üö™ D√©connexion en cours...');

        // Supprimer de chrome.storage
        await chrome.storage.local.remove(['jwtToken', 'user']);

        // Reset de l'√©tat du service worker
        authState.jwtToken = null;
        authState.user = null;
        authState.isAuthenticated = false;

        console.log('‚úÖ D√©connexion r√©ussie');
        sendResponse({ success: true });

    } catch (error) {
        console.error('‚ùå Erreur lors de la d√©connexion:', error);
        sendResponse({
            success: false,
            error: error.message
        });
    }
}

// =============================================================================
// VALIDATION TOKEN
// =============================================================================

async function validateToken() {
    if (!authState.jwtToken) {
        authState.isAuthenticated = false;
        return;
    }

    try {
        console.log('üîç Validation du token...');

        const response = await fetch(`${CONFIG.backend.baseUrl}${CONFIG.backend.endpoints.userMe}`, {
            headers: {
                'Authorization': `Bearer ${authState.jwtToken}`,
                'Content-Type': 'application/json'
            }
        });

        if (response.ok) {
            const data = await response.json();
            authState.user = data.user;
            authState.isAuthenticated = true;
            console.log('‚úÖ Token valide, utilisateur:', data.user.email);

            // Mettre √† jour le storage avec les nouvelles donn√©es
            await chrome.storage.local.set({ user: data.user });
        } else {
            console.warn('‚ö†Ô∏è Token invalide, d√©connexion...');
            await handleLogout(() => {});
        }
    } catch (error) {
        console.error('‚ùå Erreur validation token:', error);
        // Ne pas d√©connecter automatiquement en cas d'erreur r√©seau
    }
}

// =============================================================================
// VALIDATION P√âRIODIQUE DU TOKEN
// =============================================================================

// Valider le token toutes les 30 minutes
setInterval(async () => {
    if (authState.isAuthenticated) {
        console.log('üîÑ Validation p√©riodique du token...');
        await validateToken();
    }
}, 30 * 60 * 1000); // 30 minutes

console.log('üéØ Perfect Insta Service Worker initialis√©');